% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/constrainedX.R
\name{\%Xc\%}
\alias{\%Xc\%}
\title{Constrained row tensor product}
\usage{
bl1 \%Xc\% bl2
}
\arguments{
\item{bl1}{base-learner 1, e.g. \code{bols(x1)}}

\item{bl2}{base-learner 2, e.g. \code{bols(x2)}}
}
\description{
Combining single base-learners to form new, more complex base-learners, with
an identifiability constraint to center the interaction around the intercept and
around the two main effects. Suitable for functional response.
}
\details{
Similar to \code{\%X\%} in package mboost, see \code{\link[mboost]{\%X\%}}, 
a row tensor product of linear base-learners is returned by \code{\%Xc\%}. 
\code{\%Xc\%} applies a sum-to-zero constraint to the design matrix suitable for
functional response if an interaction of two scalar covariates is specified 
in the case that the model contains a global intercept and both main effects, 
as the interaction is centerd around the intercept and centered around the two main effects. 
See Web Appendix A of Brockhaus et al. (2015) for details on how to enforce the constraint 
for the functional intercept.   
Use, e.g., in a model call to \code{FDboost}, following the scheme, 
\code{y ~ 1 + bolsc(x1) + bolsc(x2) + bols(x1) \%Xc\% bols(x2)}, 
where \code{1} induces a global intercept and \code{x1}, \code{x2} are factor variables, 
see Ruegamer et al. (2018).
}
\examples{
 
######## Example for function-on-scalar-regression with interaction effect of two scalar covariates 
data("viscosity", package = "FDboost") 
## set time-interval that should be modeled
interval <- "101"

## model time until "interval" and take log() of viscosity
end <- which(viscosity$timeAll == as.numeric(interval))
viscosity$vis <- log(viscosity$visAll[,1:end])
viscosity$time <- viscosity$timeAll[1:end]
# with(viscosity, funplot(time, vis, pch = 16, cex = 0.2))

## fit model with interaction that is centered around the intercept 
## and the two main effects 
mod1 <- FDboost(vis ~ 1 + bolsc(T_C, df=1) + bolsc(T_A, df=1) + 
                bols(T_C, df=1) \%Xc\% bols(T_A, df=1),
                timeformula = ~bbs(time, df=6),
                numInt = "equal", family = QuantReg(),
                offset = NULL, offset_control = o_control(k_min = 9),
                data = viscosity, control=boost_control(mstop = 100, nu = 0.4))
                
## check centering around intercept
colMeans(predict(mod1, which = 4))

## check centering around main effects
colMeans(predict(mod1, which = 4)[viscosity$T_A == "low", ])
colMeans(predict(mod1, which = 4)[viscosity$T_A == "high", ])
colMeans(predict(mod1, which = 4)[viscosity$T_C == "low", ])
colMeans(predict(mod1, which = 4)[viscosity$T_C == "low", ])

## find optimal mstop using cvrsik() or validateFDboost()
## ... 

## look at interaction effect in one plot
# funplot(mod1$yind, predict(mod1, which=4))

}
\references{
Brockhaus, S., Scheipl, F., Hothorn, T. and Greven, S. (2015): 
The functional linear array model. Statistical Modelling, 15(3), 279-300.

Ruegamer D., Brockhaus, S., Gentsch K., Scherer, K., Greven, S. (2018). 
Boosting factor-specific functional historical models for the detection of synchronization in bioelectrical signals. 
Journal of the Royal Statistical Society: Series C (Applied Statistics), 67, 621-642.
}
\author{
Sarah Brockhaus, David Ruegamer
}
